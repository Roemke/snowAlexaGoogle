import snowboydecoder
import sys
import inspect
import os
import signal
import stt_google as stt
from subprocess import run,Popen
import shlex
import AmazonIPC as AI
import json
import time

# Demo code for listening to two hotwords at the same time, was the original from snowboy
# modified code to call alexa via the ipc interface of the demo avs service of amazon okHal()
# and the google speech to text service. The result will be passed to xdotool which 
# simulates the keyboard 

interrupted = False


def signal_handler(signal, frame):
    global interrupted
    interrupted = True


def interrupt_callback():
    global interrupted
    return interrupted


# and the callbacks if a wake word is detected
# decorator to enable beeps and print information
# just to experiment with this feature - python is new for me
class VerboseCaller(object):
    def __call__(self, func):
        return self.decorate(func)

    def decorate(self, func):
        """Wrapper factory."""
        def wrapper(wrappedObject):
            print ("Call of ", func.__name__)
            snowboydecoder.play_audio_file(snowboydecoder.DETECT_DONG)
            func(wrappedObject)
        return wrapper

class CallBackHandler(object):
    def __init__(self,path="pmdl"):
        self.buttonPositionsFile="/tmp/buttons.json"
        #json string of the buttons generated by my webinterface, example
        # {"galerie": {"top": "52", "left": "16"}, "termine": {"top": "113", "left": "16"},
        #  "fhem": {"top": "174", "left": "16"}, "radio": {"top": "235", "left": "16"},
        #  "google": {"top": "296", "left": "16"}, "chefkoch": {"top": "357", "left": "16"},
        #  "reload": {"top": "418", "left": "16"}}
        self.models = []
        self.callbacks = []
        self.sensitivity = []
        self.buttons = []
        self.noButtons = ['input','okhal','restartbrowser','close'] # keine Buttons
        self.buttonPositions = [];
        self.pmdlPath=path
        self.readPmdl()
        self.readButtonPositions()

    def readPmdl(self):
        fullPath = os.path.abspath(sys.argv[0])
        fullPath = fullPath.rsplit('/', 1)[0] + "/" + self.pmdlPath
        pmdls = os.listdir(fullPath)
        for pmdl in pmdls:
            if (pmdl.endswith('.pmdl')):
                self.models.append(fullPath + "/" + pmdl)
                callback = pmdl.split('.')[0].lower()
                self.callbacks.append(getattr(self,callback))
                if callback not in self.noButtons: self.buttons.append(callback)
                if callback in ['okhal','galerie','fhem','reload']:
                    self.sensitivity.append(0.49) # higher: better detection but more false positives
                elif callback in ['chefkoch']:
                    self.sensitivity.append(0.45)
                else:
                    self.sensitivity.append(0.4)  # maybe need to adjust

    def okhal(self):
        """
        Reaktion auf ok Hal kontaktiere alexa voice service
        """
        # snowboydecoder.play_audio_file(snowboydecoder.DETECT_DING)
        global detector, alexaConnector
        print("ok hal call")
        detector.terminate() # stop - we restart if we come back here
        if alexaConnector.connected:
            alexaConnector.sendCommand(AI.IPCommand.WAKE_WORD_DETECTED)
            alexaConnector.receiveUntilDone();
        else:
            print("No connection, try to connect again")
            alexaConnector.connect();
            if alexaConnector.connected:
                alexaConnector.sendCommand(AI.IPCommand.WAKE_WORD_DETECTED)
                alexaConnector.receiveUntilDone();
        return

    @VerboseCaller()
    def input(self):
        """
        Reaktion auf input:  kontaktiere google speech und trage den Text ein
        """
        global detector
        detector.terminate()
        #time.sleep(0.5)
        result = stt.listen_for_speech(num_phrases=1,autostart=True);
        print ("input: result of speech recognition is ",result)
        result = result[0]
        if result['confidence'] > 0.3: #start xdotool
            text = result['text'].lower()+""
            if text.startswith("l√∂sch"):
                command = "xdotool key ctrl+a BackSpace"
            else:
                if text.endswith("los") :
                    text = text.rsplit(' ',1)[0] + "\n"
                else:
                    text += ' '
                command = "xdotool type --delay 100 " + '"'+text+'"'
            self.doCommand(command)    
        return

    def readButtonPositions(self):
        try:
            with open(self.buttonPositionsFile) as datafile:
                self.buttonPositions  = json.load(datafile);
                # print("read json ",self.buttonPositions);
                 #eg   self.buttonPositions['galerie']['left'])
        except:
            print ("can't read / open ", self.buttonPositionsFile)

    def clickOnButton(self,name):
        left = int(self.buttonPositions[name]['left'])
        top =  int(self.buttonPositions[name]['top'])
        command = "xdotool mousemove {} {} click 1".format((left+10),(top+5))
        self.doCommand(command)        

    def doCommand(self,command):
        print("do ",command)
        args = shlex.split(command)
        print("args: ",args)
        run(args) #from subprocess


    def buttonAction(self,name):
        if name not in self.buttonPositions:
            self.readButtonPositions() # one try if we don't have
        if name in self.buttonPositions: # do the action with xdotool
            self.clickOnButton(name)
        else:
            print("no button positions defined in ", self.buttonPositionsFile,", this should be done by external program")

    # handler for the buttons on my raspberry interface
    #
    
    @VerboseCaller()
    def close(self):
        command ="xdotool key alt+F4"
        self.doCommand(command)

    @VerboseCaller()
    def restartbrowser(self):
        self.doCommand("killall chromium-browser")
        Popen(["chromium-browser", "--kiosk","localhost"])#subprocess run in background
                    
    @VerboseCaller()
    def galerie(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def termine(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def fhem(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def radio(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def google(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def chefkoch(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function

    @VerboseCaller()
    def reload(self):
        self.buttonAction(inspect.currentframe().f_code.co_name) # action with name of function
#-------------------------------------------------------------------

# signal abfangen
# if len(sys.argv) != 3:
#     print("Error: need to specify 2 model names")
#     print("Usage: python snowAlexaGoogle.py okHal.pmdl input.pmdl")
#     print("first model to call alexa, second to call google speech to text")
#     sys.exit(-1)


# capture SIGINT signal, e.g., Ctrl+C
signal.signal(signal.SIGINT, signal_handler)

# functions for handling the tow key-words
# okHal starts alexa (not implemented yet) input calls google speech api and redirect input to x11

callBackHandler = CallBackHandler()
# test positions
# callBackHandler.galerie()
# time.sleep(5)
# callBackHandler.termine()
# time.sleep(5)
# callBackHandler.fhem()
# time.sleep(5)
# callBackHandler.radio()
# time.sleep(5)
# callBackHandler.google()
# time.sleep(5)
# callBackHandler.chefkoch()
# time.sleep(5)
# callBackHandler.reload()
# time.sleep(5)
#exit(0)

#create detector
detector = snowboydecoder.HotwordDetector(callBackHandler.models, sensitivity=callBackHandler.sensitivity)
alexaConnector = AI.IPCConnection()
print('Listening... Press Ctrl+C to exit')
# main loop
# make sure you have the same numbers of callbacks and models
while not interrupted:
    detector.start(detected_callback=callBackHandler.callbacks,
                   interrupt_check=interrupt_callback,
                   sleep_time=0.03)
    print("interrupted or action done")
detector.terminate()
